#!/usr/bin/env python3
"""
generate_previews.py
Reads CSVs from datasets/ and writes Bootstrap table HTML snippets to
_includes/previews/<stem>.html for Jekyll to include on dataset pages.
"""

import html
import logging
import re
import sys
from datetime import date
from pathlib import Path

import pandas as pd
from jinja2 import Environment, BaseLoader

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

DATASETS_DIR = Path("datasets")
OUTPUT_DIR = Path("_includes/previews")
METADATA_DIR = Path("_datasets")
MAX_ROWS = 25
MAX_CELL_LEN = 80

logging.basicConfig(
    level=logging.INFO,
    format="%(levelname)s: %(message)s",
)
log = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Jinja2 template
# ---------------------------------------------------------------------------

TABLE_TEMPLATE = """\
<!-- Auto-generated by scripts/generate_previews.py — do not edit manually -->
<p class="text-muted small mb-2">
  Showing {{ displayed_rows }} of {{ total_rows }} row{{ "s" if total_rows != 1 else "" }},
  {{ num_cols }} column{{ "s" if num_cols != 1 else "" }}.
</p>
<table class="table table-sm table-bordered table-hover align-middle">
  <thead class="table-light">
    <tr>
      {% for col in columns %}<th scope="col">{{ col }}</th>{% endfor %}
    </tr>
  </thead>
  <tbody>
    {% for row in rows %}
    <tr>
      {% for cell in row %}<td>{{ cell }}</td>{% endfor %}
    </tr>
    {% endfor %}
  </tbody>
</table>
"""

WARNING_TEMPLATE = """\
<!-- Auto-generated by scripts/generate_previews.py — do not edit manually -->
<div class="alert alert-warning" role="alert">
  <i class="bi bi-exclamation-triangle me-2"></i>{{ message }}
</div>
"""

ERROR_TEMPLATE = """\
<!-- Auto-generated by scripts/generate_previews.py — do not edit manually -->
<div class="alert alert-danger" role="alert">
  <i class="bi bi-x-circle me-2"></i>{{ message }}
</div>
"""


def _render(template_str: str, **kwargs) -> str:
    env = Environment(loader=BaseLoader(), autoescape=False)
    return env.from_string(template_str).render(**kwargs)


def _truncate(value: str) -> str:
    """Truncate a string and HTML-escape it."""
    if len(value) > MAX_CELL_LEN:
        value = value[:MAX_CELL_LEN] + "…"
    return html.escape(value)


def update_metadata_date(stem: str) -> None:
    """
    Update the `updated:` field in _datasets/<stem>.md to today's date.
    Silently skips if the file doesn't exist or has no `updated:` line.
    """
    md_path = METADATA_DIR / f"{stem}.md"
    if not md_path.exists():
        return

    today = date.today().isoformat()  # YYYY-MM-DD
    original = md_path.read_text(encoding="utf-8")
    updated = re.sub(
        r"^(updated:\s*).*$",
        rf"\g<1>{today}",
        original,
        flags=re.MULTILINE,
    )
    if updated != original:
        md_path.write_text(updated, encoding="utf-8")
        log.info("Updated 'updated:' date in %s → %s", md_path, today)


def process_csv(csv_path: Path, output_dir: Path) -> bool:
    """
    Generate a preview HTML snippet for *csv_path*.
    Returns True on success, False on error.
    """
    stem = csv_path.stem
    out_path = output_dir / f"{stem}.html"

    # --- Empty file check ---
    if csv_path.stat().st_size == 0:
        log.warning("%s: file is empty — writing warning snippet", csv_path)
        out_path.write_text(
            _render(WARNING_TEMPLATE, message=f"No data available for {stem}."),
            encoding="utf-8",
        )
        return True

    # --- Parse ---
    try:
        df = pd.read_csv(csv_path, dtype=str, keep_default_na=False, nrows=MAX_ROWS + 1)
    except Exception as exc:  # noqa: BLE001
        log.error("%s: parse error — %s", csv_path, exc)
        out_path.write_text(
            _render(ERROR_TEMPLATE, message=f"Could not parse {stem}.csv: {html.escape(str(exc))}"),
            encoding="utf-8",
        )
        return False

    # --- Single-column warning ---
    if len(df.columns) == 1:
        log.warning(
            "%s: only 1 column detected — file may not be comma-delimited", csv_path
        )

    # Count before slicing
    total_rows = len(df)
    df = df.head(MAX_ROWS)
    displayed_rows = len(df)

    columns = [html.escape(str(c)) for c in df.columns]
    rows = [[_truncate(str(cell)) for cell in row] for row in df.itertuples(index=False)]

    snippet = _render(
        TABLE_TEMPLATE,
        columns=columns,
        rows=rows,
        displayed_rows=displayed_rows,
        total_rows=total_rows,
        num_cols=len(columns),
    )

    out_path.write_text(snippet, encoding="utf-8")
    log.info("Wrote %s (%d rows, %d cols)", out_path, displayed_rows, len(columns))
    return True


def main() -> int:
    output_dir = OUTPUT_DIR
    output_dir.mkdir(parents=True, exist_ok=True)

    csv_files = sorted(DATASETS_DIR.glob("*.csv"))
    if not csv_files:
        log.warning("No CSV files found in %s — nothing to do.", DATASETS_DIR)
        return 0

    errors = 0
    for csv_path in csv_files:
        success = process_csv(csv_path, output_dir)
        if success:
            update_metadata_date(csv_path.stem)
        else:
            errors += 1

    log.info("Done. %d file(s) processed, %d error(s).", len(csv_files), errors)
    return 1 if errors else 0


if __name__ == "__main__":
    sys.exit(main())
